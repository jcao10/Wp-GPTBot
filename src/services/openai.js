const OpenAI = require('openai');
const { getAvailabilitySummary, makeReservation, getAvailability } = require('./googleSheets');
const restaurantRules = require('../../config/restaurant-rules');
const { parseRelativeDate, validateReservationDate } = require('../utils/dateHelpers');
const { buildContextPrompt } = require('../utils/contextFormatter');

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

// Memoria conversacional en memoria (solo para pruebas)
const chatHistories = {}; // { telefono: [ {role, content}, ... ] }
const MAX_HISTORY = 20; // M√°ximo de mensajes por historial

// Estado de reserva en memoria por usuario
const reservationStates = {}; // { telefono: { name, date, time, sector, people, awaitingConfirmation: bool } }
const confirmationWords = ["s√≠", "si", "confirmo", "dale", "ok", "de acuerdo", "correcto", "afirmativo", "confirmar", "vale"]; // Puedes agregar m√°s

function isReservationComplete(state) {
  return state && state.name && state.date && state.time && state.sector && state.people;
}

function buildReservationSummary(state) {
  return `Por favor, confirma tu reserva:\nNombre: ${state.name}\nFecha: ${state.date}\nHora: ${state.time}:00\nSector: ${state.sector}\nPersonas: ${state.people}\n¬øConfirmas estos datos?`;
}

function isConfirmationMessage(msg) {
  const normalized = msg.trim().toLowerCase();
  return confirmationWords.some(word => normalized.includes(word));
}

/**
 * Genera el prompt de sistema din√°micamente usando el formateador modular
 * @param {string} availabilityData - Datos de disponibilidad opcionales
 * @returns {string} Prompt completo para OpenAI
 */
function buildSystemPrompt(availabilityData = null) {
  let prompt = buildContextPrompt(restaurantRules);

  // Agrega disponibilidad si corresponde
  if (availabilityData) {
    prompt += `\n\n### DISPONIBILIDAD ACTUAL\n${availabilityData}\n`;
  }

  return prompt;
}

/**
 * Builds the reservation parser prompt from configuration
 * @returns {string} Parser system prompt
 */
function buildReservationParserPrompt() {
  const rules = restaurantRules;
  
  return `You are an expert reservation parser. Your task is to analyze a user's message and determine if they intend to make a reservation. Always respond with a JSON object.

Current date: ${new Date().toISOString().split('T')[0]}

JSON response format:
{
  "isReservation": boolean (true ONLY if the user shows clear intent to reserve),
  "name": "" (if found, leave empty if not),
  "date": "" (convert relative dates like "ma√±ana" or "hoy"; leave empty if not found),
  "time": "" (leave empty if not found),
  "sector": "" ("Interior" or "Terraza", ONLY if specified by the user),
  "people": "" (number, ONLY if specified by the user)
}

IMPORTANT RULES:
- Your most important job is to set "isReservation" correctly.
- Set "isReservation" to \`true\` if the message contains reservation keywords ("reserva", "mesa", "lugar"), a date, a time, a number of people, or a name for a booking.
- Set "isReservation" to \`false\` for simple greetings ("Hola"), general questions ("tienen delivery?"), etc.
- If no information is specified for a field, leave it as an empty string "".
- Do NOT mistake greetings like "Hola" for a name.

Examples:
- User: "Hola" ‚Üí {"isReservation": false, "name": "", "date": "", "time": "", "sector": "", "people": ""}
- User: "quiero reservar para ma√±ana" ‚Üí {"isReservation": true, "name": "", "date": "tomorrow", "time": "", "sector": "", "people": ""}
- User: "soy Mar√≠a, para 4 personas" ‚Üí {"isReservation": true, "name": "Mar√≠a", "date": "", "time": "", "sector": "", "people": 4}
- User: "mesa para 2 en la terraza" ‚Üí {"isReservation": true, "name": "", "date": "", "time": "", "sector": "Terraza", "people": 2}
- User: "¬øtienen delivery?" ‚Üí {"isReservation": false, "name": "", "date": "", "time": "", "sector": "", "people": ""}`;
}

/**
 * Generates a creative and friendly prompt to ask for missing reservation information.
 * @param {string[]} missingInfo - Array of missing details (e.g., ['la fecha', 'el nombre']).
 * @returns {Promise<string>} A human-like question generated by OpenAI.
 */
async function generateMissingInfoResponse(missingInfo) {
  let requestText;
  if (missingInfo.length === 1) {
    requestText = `el siguiente dato: ${missingInfo[0]}`;
  } else {
    const lastItem = missingInfo.pop();
    requestText = `los siguientes datos: ${missingInfo.join(', ')} y ${lastItem}`;
  }

  const prompt = `Eres un asistente de restaurante amigable y profesional. Est√°s ayudando a un cliente a hacer una reserva, pero necesitas m√°s informaci√≥n. 
  P√≠dele al cliente de forma natural y conversacional ${requestText}.
  S√© breve y directo, pero no suenes como un robot. Var√≠a tus respuestas.`;

  try {
    const completion = await openai.chat.completions.create({
      model: "gpt-3.5-turbo",
      messages: [
        { role: "system", content: prompt }
      ],
      temperature: 0.7, // A√±adimos un poco de creatividad
    });
    return completion.choices[0].message.content;
  } catch (error) {
    console.error("Error generating missing info response:", error);
    // Fallback a la respuesta gen√©rica si falla la API
    return `¬°Casi lo tenemos! Para completar tu reserva, me falta que me digas: ${requestText}.`;
  }
}

/**
 * Extracts reservation details from a user message using AI
 * @param {string} userMessage - The user's message
 * @param {string} userPhone - The user's phone number
 * @returns {Promise<Object|null>} Reservation details or null if not a reservation request
 */
async function extractReservationDetails(userMessage, userPhone) {
  try {
    const completion = await openai.chat.completions.create({
      model: "gpt-3.5-turbo",
      messages: [
        {
          role: "system",
          content: buildReservationParserPrompt()
        },
        {
          role: "user",
          content: userMessage
        }
      ],
    });

    const response = completion.choices[0].message.content.trim();
    console.log(`ü§ñ AI reservation parsing result: ${response}`);

    try {
      const reservationData = JSON.parse(response);
      
      // Siempre enriquecer con el tel√©fono
      reservationData.phone = userPhone;
      
      // Procesar y validar la fecha si existe
      if (reservationData.date) {
        if (reservationData.date === 'today' || reservationData.date === 'hoy') {
          reservationData.date = new Date().toISOString().split('T')[0];
        } else if (reservationData.date === 'tomorrow' || reservationData.date === 'ma√±ana') {
          const tomorrow = new Date();
          tomorrow.setDate(tomorrow.getDate() + 1);
          reservationData.date = tomorrow.toISOString().split('T')[0];
        } else {
          reservationData.date = parseRelativeDate(reservationData.date);
        }
        
        // Validar la fecha procesada
        const dateValidation = validateReservationDate(reservationData.date, restaurantRules);
        if (!dateValidation.valid) {
          return {
            type: "date_error",
            error: dateValidation.error
          };
        }
      }
      
      // Devolver siempre los datos extra√≠dos para que la funci√≥n principal decida qu√© hacer
      return {
        extractedData: reservationData
      };

    } catch (parseError) {
      console.error('Error parsing reservation JSON:', parseError);
    }

    return null; // Solo devolver null si el JSON es inv√°lido
  } catch (error) {
    console.error('Error extracting reservation details:', error);
    return null;
  }
}

/**
 * Gets a response from the OpenAI API based on a user's message.
 * @param {string} userMessage The message sent by the user.
 * @param {string} userPhone The user's phone number.
 * @returns {Promise<string>} The AI-generated response.
 */
async function getChatGptResponse(userMessage, userPhone) {
  try {
    // Recuperar historial de este usuario
    if (!chatHistories[userPhone]) {
      chatHistories[userPhone] = [];
    }
    const history = chatHistories[userPhone];

    // Inicializar estado de reserva si no existe
    if (!reservationStates[userPhone]) {
      reservationStates[userPhone] = { awaitingConfirmation: false };
    }
    const state = reservationStates[userPhone];

    // Si estamos esperando confirmaci√≥n y el usuario responde afirmativamente
    if (state.awaitingConfirmation && isConfirmationMessage(userMessage)) {
      // Validar que el estado est√© completo antes de guardar
      if (!isReservationComplete(state)) {
        // Buscar qu√© dato falta
        const missing = [];
        if (!state.name) missing.push('nombre');
        if (!state.date) missing.push('fecha');
        if (!state.time) missing.push('hora');
        if (!state.sector) missing.push('sector');
        if (!state.people) missing.push('personas');
        return `Antes de confirmar, necesito que me indiques: ${missing.join(', ')}.`;
      }
      // Validar disponibilidad real en Google Sheets usando la fecha de la reserva
      console.log(`[RESERVA][ANTES DE CONSULTAR SHEETS] Fecha a consultar: ${state.date}`);
      const slots = await getAvailability(state.date);
      console.log(`[RESERVA][DESPU√âS DE CONSULTAR SHEETS] Fecha consultada: ${state.date}`);
      const slot = slots.find(s =>
        parseInt(s.time) === parseInt(state.time) && // Comparamos como n√∫meros para evitar errores de formato
        s.sector.toLowerCase() === state.sector.toLowerCase() &&
        (!s.reservedName && !s.reservedPhone)
      );
      if (!slot) {
        return `Lo siento, el horario ${state.time}:00 en ${state.sector} para el ${state.date} ya no est√° disponible. Por favor, elige otro horario o sector.`;
      }
      // Llamar a Google Sheets para guardar la reserva
      const result = await makeReservation(state);
      // Limpiar estado
      delete reservationStates[userPhone];
      // Guardar en historial
      history.push({ role: "user", content: userMessage });
      let response;
      if (result.success) {
        response = `¬°Tu reserva ha sido confirmada! ${result.message}`;
      } else {
        response = `No se pudo confirmar la reserva: ${result.message}`;
      }
      history.push({ role: "assistant", content: response });
      if (history.length > MAX_HISTORY * 2) {
        chatHistories[userPhone] = history.slice(-MAX_HISTORY * 2);
      }
      return response;
    }

    // Si el usuario responde "no" o algo similar, permitir modificar (opcional, aqu√≠ solo reiniciamos)
    if (state.awaitingConfirmation && userMessage.trim().toLowerCase().startsWith("no")) {
      state.awaitingConfirmation = false;
      // Limpiamos el estado para que pueda empezar de nuevo o modificar
      delete reservationStates[userPhone]; 
      return "¬°Entendido! Empecemos de nuevo. ¬øPara qu√© fecha, hora y cu√°ntas personas te gustar√≠a reservar?";
    }

    // Extraer datos del mensaje actual
    const reservationDetails = await extractReservationDetails(userMessage, userPhone);

    // --- INICIO DE LA L√ìGICA REFACTORIZADA ---

    // 1. Manejar errores de validaci√≥n de fecha primero
    if (reservationDetails && reservationDetails.type === 'date_error') {
      return reservationDetails.error;
    }

    // 2. Siempre intentar actualizar el estado con cualquier dato extra√≠do
    const data = reservationDetails ? (reservationDetails.data || reservationDetails.extractedData) : null;
    if (data) {
        console.log("üìù Updating reservation state with any extracted data:", data);
        if (data.name && data.name !== "customer name") state.name = data.name;
        if (data.date) state.date = data.date;
        if (data.time) state.time = data.time;
        if (data.sector) state.sector = data.sector;
        if (data.people) state.people = data.people;
        if (data.phone) state.phone = data.phone;
    }

    // 3. Revisar si, tras la actualizaci√≥n, la reserva est√° completa
    if (isReservationComplete(state)) {
        state.awaitingConfirmation = true;
        const summary = buildReservationSummary(state);
        history.push({ role: "user", content: userMessage });
        history.push({ role: "assistant", content: summary });
        return summary;
    }

    // 4. Si la intenci√≥n era claramente de reserva pero faltan datos, pedirlos.
    //    Si era una pregunta mixta (isReservation: false), la l√≥gica continuar√°
    //    y ser√° manejada por el LLM general m√°s abajo.
    if (data && data.isReservation) {
        const missing = [];
        if (!state.name || state.name === "customer name") missing.push('tu nombre');
        if (!state.date) missing.push('la fecha');
        if (!state.time) missing.push('la hora');
        if (!state.people) missing.push('la cantidad de personas');
        if (!state.sector) missing.push('el sector (Interior o Terraza)');

        if (missing.length > 0) {
            const response = await generateMissingInfoResponse(missing);
            history.push({ role: "user", content: userMessage });
            history.push({ role: "assistant", content: response });
            return response;
        }
    }
    
    // --- FIN DE LA L√ìGICA REFACTORIZADA ---

    // --- L√ìGICA DE DISPONIBILIDAD Y RESPUESTA GENERAL ---
    // (Esta parte ahora se ejecutar√° para preguntas mixtas, lo cual es correcto)
    let fechaConsulta = null;
    if (data && data.date) {
      fechaConsulta = data.date;
      console.log(`[DISPONIBILIDAD][PARSER] Fecha extra√≠da del mensaje: ${fechaConsulta}`);
    }

    // Construir el contexto de sistema
    let systemPrompt;
    const isAskingAboutAvailability = userMessage.toLowerCase().includes('disponibilidad') ||
                                      userMessage.toLowerCase().includes('reserva') ||
                                      userMessage.toLowerCase().includes('mesa') ||
                                      userMessage.toLowerCase().includes('availability') ||
                                      userMessage.toLowerCase().includes('book') ||
                                      userMessage.toLowerCase().includes('table');
    if (isAskingAboutAvailability) {
      let availabilityData;
      let fechaParaConsulta;
      if (fechaConsulta) {
        fechaParaConsulta = fechaConsulta;
      } else {
        // Si no se provey√≥ una fecha, en lugar de asumir hoy, preguntamos al usuario.
        const response = "¬øPara qu√© fecha te gustar√≠a consultar la disponibilidad?";
        history.push({ role: "user", content: userMessage });
        history.push({ role: "assistant", content: response });
        return response;
      }
      console.log(`[DISPONIBILIDAD][ANTES DE CONSULTAR SHEETS] Fecha a consultar: ${fechaParaConsulta}`);
      availabilityData = await getAvailabilitySummary(fechaParaConsulta);
      console.log(`[DISPONIBILIDAD][DESPU√âS DE CONSULTAR SHEETS] Fecha consultada: ${fechaParaConsulta}`);
      systemPrompt = buildSystemPrompt(availabilityData);
    } else {
      systemPrompt = buildSystemPrompt();
    }

    // Armar el historial para OpenAI
    const messages = [
      { role: "system", content: systemPrompt },
      ...history,
      { role: "user", content: userMessage }
    ];

    // Llamar a OpenAI con el historial
    console.log("==== PROMPT ENVIADO A OPENAI ====");
    console.dir(messages, { depth: null });
    console.log("=================================");
    const completion = await openai.chat.completions.create({
      model: "gpt-3.5-turbo",
      messages: messages,
    });

    const response = completion.choices[0].message.content;
    // Guardar en historial
    history.push({ role: "user", content: userMessage });
    history.push({ role: "assistant", content: response });
    if (history.length > MAX_HISTORY * 2) {
      chatHistories[userPhone] = history.slice(-MAX_HISTORY * 2);
    }
    return response;
  } catch (error) {
    console.error("Error getting response from OpenAI:", error);
    return "Lo siento, estoy teniendo problemas para conectarme con mi cerebro de IA en este momento. Por favor, int√©ntalo de nuevo m√°s tarde.";
  }
}

module.exports = {
  getChatGptResponse,
}; 